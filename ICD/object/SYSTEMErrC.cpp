// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.3.0
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:376


#include "SYSTEMErrC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/CDR.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "SYSTEMErrC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::SYSTEMErrEx::SYSTEMErrEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SYSTEMErrEx:1.0",
        "SYSTEMErrEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::SYSTEMErrEx::SYSTEMErrEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SYSTEMErrEx:1.0",
        "SYSTEMErrEx"
      )
{
}

SYSTEMErr::SYSTEMErrEx::~SYSTEMErrEx (void)
{
}

SYSTEMErr::SYSTEMErrEx::SYSTEMErrEx (const ::SYSTEMErr::SYSTEMErrEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::SYSTEMErrEx&
SYSTEMErr::SYSTEMErrEx::operator= (const ::SYSTEMErr::SYSTEMErrEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::SYSTEMErrEx::_tao_any_destructor (void *_tao_void_pointer)
{
  SYSTEMErrEx *_tao_tmp_pointer =
    static_cast<SYSTEMErrEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::SYSTEMErrEx *
SYSTEMErr::SYSTEMErrEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<SYSTEMErrEx *> (_tao_excp);
}

const SYSTEMErr::SYSTEMErrEx *
SYSTEMErr::SYSTEMErrEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const SYSTEMErrEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::SYSTEMErrEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::SYSTEMErrEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::SYSTEMErrEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::SYSTEMErrEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::SYSTEMErrEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::SYSTEMErrEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::SYSTEMErrEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::SYSTEMErrEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_SYSTEMErrEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_SYSTEMErrEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_SYSTEMErrEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/SYSTEMErrEx:1.0",
  "SYSTEMErrEx",
  _tao_fields_SYSTEMErr_SYSTEMErrEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_SYSTEMErrEx =
    &_tao_tc_SYSTEMErr_SYSTEMErrEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::AlreadyInAutomaticEx::AlreadyInAutomaticEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/AlreadyInAutomaticEx:1.0",
        "AlreadyInAutomaticEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::AlreadyInAutomaticEx::AlreadyInAutomaticEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/AlreadyInAutomaticEx:1.0",
        "AlreadyInAutomaticEx"
      )
{
}

SYSTEMErr::AlreadyInAutomaticEx::~AlreadyInAutomaticEx (void)
{
}

SYSTEMErr::AlreadyInAutomaticEx::AlreadyInAutomaticEx (const ::SYSTEMErr::AlreadyInAutomaticEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::AlreadyInAutomaticEx&
SYSTEMErr::AlreadyInAutomaticEx::operator= (const ::SYSTEMErr::AlreadyInAutomaticEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor (void *_tao_void_pointer)
{
  AlreadyInAutomaticEx *_tao_tmp_pointer =
    static_cast<AlreadyInAutomaticEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::AlreadyInAutomaticEx *
SYSTEMErr::AlreadyInAutomaticEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<AlreadyInAutomaticEx *> (_tao_excp);
}

const SYSTEMErr::AlreadyInAutomaticEx *
SYSTEMErr::AlreadyInAutomaticEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const AlreadyInAutomaticEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::AlreadyInAutomaticEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::AlreadyInAutomaticEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::AlreadyInAutomaticEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::AlreadyInAutomaticEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::AlreadyInAutomaticEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::AlreadyInAutomaticEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::AlreadyInAutomaticEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::AlreadyInAutomaticEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_AlreadyInAutomaticEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_AlreadyInAutomaticEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_AlreadyInAutomaticEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/AlreadyInAutomaticEx:1.0",
  "AlreadyInAutomaticEx",
  _tao_fields_SYSTEMErr_AlreadyInAutomaticEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_AlreadyInAutomaticEx =
    &_tao_tc_SYSTEMErr_AlreadyInAutomaticEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::PositionOutOfLimitsEx::PositionOutOfLimitsEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/PositionOutOfLimitsEx:1.0",
        "PositionOutOfLimitsEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::PositionOutOfLimitsEx::PositionOutOfLimitsEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/PositionOutOfLimitsEx:1.0",
        "PositionOutOfLimitsEx"
      )
{
}

SYSTEMErr::PositionOutOfLimitsEx::~PositionOutOfLimitsEx (void)
{
}

SYSTEMErr::PositionOutOfLimitsEx::PositionOutOfLimitsEx (const ::SYSTEMErr::PositionOutOfLimitsEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::PositionOutOfLimitsEx&
SYSTEMErr::PositionOutOfLimitsEx::operator= (const ::SYSTEMErr::PositionOutOfLimitsEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor (void *_tao_void_pointer)
{
  PositionOutOfLimitsEx *_tao_tmp_pointer =
    static_cast<PositionOutOfLimitsEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::PositionOutOfLimitsEx *
SYSTEMErr::PositionOutOfLimitsEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<PositionOutOfLimitsEx *> (_tao_excp);
}

const SYSTEMErr::PositionOutOfLimitsEx *
SYSTEMErr::PositionOutOfLimitsEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const PositionOutOfLimitsEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::PositionOutOfLimitsEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::PositionOutOfLimitsEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::PositionOutOfLimitsEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::PositionOutOfLimitsEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::PositionOutOfLimitsEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::PositionOutOfLimitsEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::PositionOutOfLimitsEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::PositionOutOfLimitsEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_PositionOutOfLimitsEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_PositionOutOfLimitsEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_PositionOutOfLimitsEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/PositionOutOfLimitsEx:1.0",
  "PositionOutOfLimitsEx",
  _tao_fields_SYSTEMErr_PositionOutOfLimitsEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_PositionOutOfLimitsEx =
    &_tao_tc_SYSTEMErr_PositionOutOfLimitsEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::ProposalNotYetReadyEx::ProposalNotYetReadyEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ProposalNotYetReadyEx:1.0",
        "ProposalNotYetReadyEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::ProposalNotYetReadyEx::ProposalNotYetReadyEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ProposalNotYetReadyEx:1.0",
        "ProposalNotYetReadyEx"
      )
{
}

SYSTEMErr::ProposalNotYetReadyEx::~ProposalNotYetReadyEx (void)
{
}

SYSTEMErr::ProposalNotYetReadyEx::ProposalNotYetReadyEx (const ::SYSTEMErr::ProposalNotYetReadyEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::ProposalNotYetReadyEx&
SYSTEMErr::ProposalNotYetReadyEx::operator= (const ::SYSTEMErr::ProposalNotYetReadyEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor (void *_tao_void_pointer)
{
  ProposalNotYetReadyEx *_tao_tmp_pointer =
    static_cast<ProposalNotYetReadyEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::ProposalNotYetReadyEx *
SYSTEMErr::ProposalNotYetReadyEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ProposalNotYetReadyEx *> (_tao_excp);
}

const SYSTEMErr::ProposalNotYetReadyEx *
SYSTEMErr::ProposalNotYetReadyEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ProposalNotYetReadyEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::ProposalNotYetReadyEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::ProposalNotYetReadyEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::ProposalNotYetReadyEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::ProposalNotYetReadyEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::ProposalNotYetReadyEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::ProposalNotYetReadyEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::ProposalNotYetReadyEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::ProposalNotYetReadyEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_ProposalNotYetReadyEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_ProposalNotYetReadyEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_ProposalNotYetReadyEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/ProposalNotYetReadyEx:1.0",
  "ProposalNotYetReadyEx",
  _tao_fields_SYSTEMErr_ProposalNotYetReadyEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_ProposalNotYetReadyEx =
    &_tao_tc_SYSTEMErr_ProposalNotYetReadyEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::InvalidProposalStatusTransitionEx::InvalidProposalStatusTransitionEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/InvalidProposalStatusTransitionEx:1.0",
        "InvalidProposalStatusTransitionEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::InvalidProposalStatusTransitionEx::InvalidProposalStatusTransitionEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/InvalidProposalStatusTransitionEx:1.0",
        "InvalidProposalStatusTransitionEx"
      )
{
}

SYSTEMErr::InvalidProposalStatusTransitionEx::~InvalidProposalStatusTransitionEx (void)
{
}

SYSTEMErr::InvalidProposalStatusTransitionEx::InvalidProposalStatusTransitionEx (const ::SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::InvalidProposalStatusTransitionEx&
SYSTEMErr::InvalidProposalStatusTransitionEx::operator= (const ::SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidProposalStatusTransitionEx *_tao_tmp_pointer =
    static_cast<InvalidProposalStatusTransitionEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::InvalidProposalStatusTransitionEx *
SYSTEMErr::InvalidProposalStatusTransitionEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<InvalidProposalStatusTransitionEx *> (_tao_excp);
}

const SYSTEMErr::InvalidProposalStatusTransitionEx *
SYSTEMErr::InvalidProposalStatusTransitionEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const InvalidProposalStatusTransitionEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::InvalidProposalStatusTransitionEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::InvalidProposalStatusTransitionEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::InvalidProposalStatusTransitionEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::InvalidProposalStatusTransitionEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_InvalidProposalStatusTransitionEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_InvalidProposalStatusTransitionEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_InvalidProposalStatusTransitionEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/InvalidProposalStatusTransitionEx:1.0",
  "InvalidProposalStatusTransitionEx",
  _tao_fields_SYSTEMErr_InvalidProposalStatusTransitionEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_InvalidProposalStatusTransitionEx =
    &_tao_tc_SYSTEMErr_InvalidProposalStatusTransitionEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::ImageAlreadyStoredEx::ImageAlreadyStoredEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ImageAlreadyStoredEx:1.0",
        "ImageAlreadyStoredEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::ImageAlreadyStoredEx::ImageAlreadyStoredEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/ImageAlreadyStoredEx:1.0",
        "ImageAlreadyStoredEx"
      )
{
}

SYSTEMErr::ImageAlreadyStoredEx::~ImageAlreadyStoredEx (void)
{
}

SYSTEMErr::ImageAlreadyStoredEx::ImageAlreadyStoredEx (const ::SYSTEMErr::ImageAlreadyStoredEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::ImageAlreadyStoredEx&
SYSTEMErr::ImageAlreadyStoredEx::operator= (const ::SYSTEMErr::ImageAlreadyStoredEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor (void *_tao_void_pointer)
{
  ImageAlreadyStoredEx *_tao_tmp_pointer =
    static_cast<ImageAlreadyStoredEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::ImageAlreadyStoredEx *
SYSTEMErr::ImageAlreadyStoredEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<ImageAlreadyStoredEx *> (_tao_excp);
}

const SYSTEMErr::ImageAlreadyStoredEx *
SYSTEMErr::ImageAlreadyStoredEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const ImageAlreadyStoredEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::ImageAlreadyStoredEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::ImageAlreadyStoredEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::ImageAlreadyStoredEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::ImageAlreadyStoredEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::ImageAlreadyStoredEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::ImageAlreadyStoredEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::ImageAlreadyStoredEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::ImageAlreadyStoredEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_ImageAlreadyStoredEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_ImageAlreadyStoredEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_ImageAlreadyStoredEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/ImageAlreadyStoredEx:1.0",
  "ImageAlreadyStoredEx",
  _tao_fields_SYSTEMErr_ImageAlreadyStoredEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_ImageAlreadyStoredEx =
    &_tao_tc_SYSTEMErr_ImageAlreadyStoredEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::CameraIsOffEx::CameraIsOffEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/CameraIsOffEx:1.0",
        "CameraIsOffEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::CameraIsOffEx::CameraIsOffEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/CameraIsOffEx:1.0",
        "CameraIsOffEx"
      )
{
}

SYSTEMErr::CameraIsOffEx::~CameraIsOffEx (void)
{
}

SYSTEMErr::CameraIsOffEx::CameraIsOffEx (const ::SYSTEMErr::CameraIsOffEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::CameraIsOffEx&
SYSTEMErr::CameraIsOffEx::operator= (const ::SYSTEMErr::CameraIsOffEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::CameraIsOffEx::_tao_any_destructor (void *_tao_void_pointer)
{
  CameraIsOffEx *_tao_tmp_pointer =
    static_cast<CameraIsOffEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::CameraIsOffEx *
SYSTEMErr::CameraIsOffEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CameraIsOffEx *> (_tao_excp);
}

const SYSTEMErr::CameraIsOffEx *
SYSTEMErr::CameraIsOffEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CameraIsOffEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::CameraIsOffEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::CameraIsOffEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::CameraIsOffEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::CameraIsOffEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::CameraIsOffEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::CameraIsOffEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::CameraIsOffEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::CameraIsOffEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_CameraIsOffEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_CameraIsOffEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_CameraIsOffEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/CameraIsOffEx:1.0",
  "CameraIsOffEx",
  _tao_fields_SYSTEMErr_CameraIsOffEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_CameraIsOffEx =
    &_tao_tc_SYSTEMErr_CameraIsOffEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::SchedulerAlreadyRunningEx::SchedulerAlreadyRunningEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SchedulerAlreadyRunningEx:1.0",
        "SchedulerAlreadyRunningEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::SchedulerAlreadyRunningEx::SchedulerAlreadyRunningEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SchedulerAlreadyRunningEx:1.0",
        "SchedulerAlreadyRunningEx"
      )
{
}

SYSTEMErr::SchedulerAlreadyRunningEx::~SchedulerAlreadyRunningEx (void)
{
}

SYSTEMErr::SchedulerAlreadyRunningEx::SchedulerAlreadyRunningEx (const ::SYSTEMErr::SchedulerAlreadyRunningEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::SchedulerAlreadyRunningEx&
SYSTEMErr::SchedulerAlreadyRunningEx::operator= (const ::SYSTEMErr::SchedulerAlreadyRunningEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor (void *_tao_void_pointer)
{
  SchedulerAlreadyRunningEx *_tao_tmp_pointer =
    static_cast<SchedulerAlreadyRunningEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::SchedulerAlreadyRunningEx *
SYSTEMErr::SchedulerAlreadyRunningEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<SchedulerAlreadyRunningEx *> (_tao_excp);
}

const SYSTEMErr::SchedulerAlreadyRunningEx *
SYSTEMErr::SchedulerAlreadyRunningEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const SchedulerAlreadyRunningEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::SchedulerAlreadyRunningEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::SchedulerAlreadyRunningEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::SchedulerAlreadyRunningEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::SchedulerAlreadyRunningEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::SchedulerAlreadyRunningEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::SchedulerAlreadyRunningEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::SchedulerAlreadyRunningEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::SchedulerAlreadyRunningEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_SchedulerAlreadyRunningEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_SchedulerAlreadyRunningEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_SchedulerAlreadyRunningEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/SchedulerAlreadyRunningEx:1.0",
  "SchedulerAlreadyRunningEx",
  _tao_fields_SYSTEMErr_SchedulerAlreadyRunningEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_SchedulerAlreadyRunningEx =
    &_tao_tc_SYSTEMErr_SchedulerAlreadyRunningEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::SchedulerAlreadyStoppedEx::SchedulerAlreadyStoppedEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SchedulerAlreadyStoppedEx:1.0",
        "SchedulerAlreadyStoppedEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::SchedulerAlreadyStoppedEx::SchedulerAlreadyStoppedEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SchedulerAlreadyStoppedEx:1.0",
        "SchedulerAlreadyStoppedEx"
      )
{
}

SYSTEMErr::SchedulerAlreadyStoppedEx::~SchedulerAlreadyStoppedEx (void)
{
}

SYSTEMErr::SchedulerAlreadyStoppedEx::SchedulerAlreadyStoppedEx (const ::SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::SchedulerAlreadyStoppedEx&
SYSTEMErr::SchedulerAlreadyStoppedEx::operator= (const ::SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor (void *_tao_void_pointer)
{
  SchedulerAlreadyStoppedEx *_tao_tmp_pointer =
    static_cast<SchedulerAlreadyStoppedEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::SchedulerAlreadyStoppedEx *
SYSTEMErr::SchedulerAlreadyStoppedEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<SchedulerAlreadyStoppedEx *> (_tao_excp);
}

const SYSTEMErr::SchedulerAlreadyStoppedEx *
SYSTEMErr::SchedulerAlreadyStoppedEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const SchedulerAlreadyStoppedEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::SchedulerAlreadyStoppedEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::SchedulerAlreadyStoppedEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::SchedulerAlreadyStoppedEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::SchedulerAlreadyStoppedEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_SchedulerAlreadyStoppedEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_SchedulerAlreadyStoppedEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_SchedulerAlreadyStoppedEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/SchedulerAlreadyStoppedEx:1.0",
  "SchedulerAlreadyStoppedEx",
  _tao_fields_SYSTEMErr_SchedulerAlreadyStoppedEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_SchedulerAlreadyStoppedEx =
    &_tao_tc_SYSTEMErr_SchedulerAlreadyStoppedEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::NoProposalExecutingEx::NoProposalExecutingEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/NoProposalExecutingEx:1.0",
        "NoProposalExecutingEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::NoProposalExecutingEx::NoProposalExecutingEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/NoProposalExecutingEx:1.0",
        "NoProposalExecutingEx"
      )
{
}

SYSTEMErr::NoProposalExecutingEx::~NoProposalExecutingEx (void)
{
}

SYSTEMErr::NoProposalExecutingEx::NoProposalExecutingEx (const ::SYSTEMErr::NoProposalExecutingEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::NoProposalExecutingEx&
SYSTEMErr::NoProposalExecutingEx::operator= (const ::SYSTEMErr::NoProposalExecutingEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor (void *_tao_void_pointer)
{
  NoProposalExecutingEx *_tao_tmp_pointer =
    static_cast<NoProposalExecutingEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::NoProposalExecutingEx *
SYSTEMErr::NoProposalExecutingEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<NoProposalExecutingEx *> (_tao_excp);
}

const SYSTEMErr::NoProposalExecutingEx *
SYSTEMErr::NoProposalExecutingEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const NoProposalExecutingEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::NoProposalExecutingEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::NoProposalExecutingEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::NoProposalExecutingEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::NoProposalExecutingEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::NoProposalExecutingEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::NoProposalExecutingEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::NoProposalExecutingEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::NoProposalExecutingEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_NoProposalExecutingEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_NoProposalExecutingEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_NoProposalExecutingEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/NoProposalExecutingEx:1.0",
  "NoProposalExecutingEx",
  _tao_fields_SYSTEMErr_NoProposalExecutingEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_NoProposalExecutingEx =
    &_tao_tc_SYSTEMErr_NoProposalExecutingEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::SystemInAutoModeEx::SystemInAutoModeEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SystemInAutoModeEx:1.0",
        "SystemInAutoModeEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::SystemInAutoModeEx::SystemInAutoModeEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/SystemInAutoModeEx:1.0",
        "SystemInAutoModeEx"
      )
{
}

SYSTEMErr::SystemInAutoModeEx::~SystemInAutoModeEx (void)
{
}

SYSTEMErr::SystemInAutoModeEx::SystemInAutoModeEx (const ::SYSTEMErr::SystemInAutoModeEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::SystemInAutoModeEx&
SYSTEMErr::SystemInAutoModeEx::operator= (const ::SYSTEMErr::SystemInAutoModeEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor (void *_tao_void_pointer)
{
  SystemInAutoModeEx *_tao_tmp_pointer =
    static_cast<SystemInAutoModeEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::SystemInAutoModeEx *
SYSTEMErr::SystemInAutoModeEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<SystemInAutoModeEx *> (_tao_excp);
}

const SYSTEMErr::SystemInAutoModeEx *
SYSTEMErr::SystemInAutoModeEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const SystemInAutoModeEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::SystemInAutoModeEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::SystemInAutoModeEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::SystemInAutoModeEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::SystemInAutoModeEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::SystemInAutoModeEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::SystemInAutoModeEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::SystemInAutoModeEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::SystemInAutoModeEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_SystemInAutoModeEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_SystemInAutoModeEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_SystemInAutoModeEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/SystemInAutoModeEx:1.0",
  "SystemInAutoModeEx",
  _tao_fields_SYSTEMErr_SystemInAutoModeEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_SystemInAutoModeEx =
    &_tao_tc_SYSTEMErr_SystemInAutoModeEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:54

SYSTEMErr::CannotOpenDeviceEx::CannotOpenDeviceEx (
    const ACSErr::ErrorTrace & _tao_errorTrace)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/CannotOpenDeviceEx:1.0",
        "CannotOpenDeviceEx"
      )
{
  this->errorTrace = _tao_errorTrace;
}



// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:101

SYSTEMErr::CannotOpenDeviceEx::CannotOpenDeviceEx (void)
  : ::CORBA::UserException (
        "IDL:acsws/SYSTEMErr/CannotOpenDeviceEx:1.0",
        "CannotOpenDeviceEx"
      )
{
}

SYSTEMErr::CannotOpenDeviceEx::~CannotOpenDeviceEx (void)
{
}

SYSTEMErr::CannotOpenDeviceEx::CannotOpenDeviceEx (const ::SYSTEMErr::CannotOpenDeviceEx &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->errorTrace = _tao_excp.errorTrace;
}

SYSTEMErr::CannotOpenDeviceEx&
SYSTEMErr::CannotOpenDeviceEx::operator= (const ::SYSTEMErr::CannotOpenDeviceEx &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->errorTrace = _tao_excp.errorTrace;
  return *this;
}

void SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor (void *_tao_void_pointer)
{
  CannotOpenDeviceEx *_tao_tmp_pointer =
    static_cast<CannotOpenDeviceEx *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

SYSTEMErr::CannotOpenDeviceEx *
SYSTEMErr::CannotOpenDeviceEx::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<CannotOpenDeviceEx *> (_tao_excp);
}

const SYSTEMErr::CannotOpenDeviceEx *
SYSTEMErr::CannotOpenDeviceEx::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const CannotOpenDeviceEx *> (_tao_excp);
}

::CORBA::Exception *SYSTEMErr::CannotOpenDeviceEx::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::SYSTEMErr::CannotOpenDeviceEx, 0);
  return retval;
}

::CORBA::Exception *
SYSTEMErr::CannotOpenDeviceEx::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::SYSTEMErr::CannotOpenDeviceEx (*this),
      0
    );
  return result;
}

void SYSTEMErr::CannotOpenDeviceEx::_raise (void) const
{
  throw *this;
}

void SYSTEMErr::CannotOpenDeviceEx::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void SYSTEMErr::CannotOpenDeviceEx::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr SYSTEMErr::CannotOpenDeviceEx::_tao_type (void) const
{
  return ::SYSTEMErr::_tc_CannotOpenDeviceEx;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:88

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SYSTEMErr_CannotOpenDeviceEx[] =
      {
        { "errorTrace", &ACSErr::_tc_ErrorTrace }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SYSTEMErr_CannotOpenDeviceEx (
  ::CORBA::tk_except,
  "IDL:acsws/SYSTEMErr/CannotOpenDeviceEx:1.0",
  "CannotOpenDeviceEx",
  _tao_fields_SYSTEMErr_CannotOpenDeviceEx,
  1);


namespace SYSTEMErr
{
  ::CORBA::TypeCode_ptr const _tc_CannotOpenDeviceEx =
    &_tao_tc_SYSTEMErr_CannotOpenDeviceEx;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::SYSTEMErrEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::SYSTEMErrEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::SYSTEMErrEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::SYSTEMErrEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_SYSTEMErrEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::SYSTEMErrEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::SYSTEMErrEx>::insert (
        _tao_any,
        ::SYSTEMErr::SYSTEMErrEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_SYSTEMErrEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::SYSTEMErrEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::SYSTEMErrEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::SYSTEMErrEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::SYSTEMErrEx>::extract (
          _tao_any,
          ::SYSTEMErr::SYSTEMErrEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_SYSTEMErrEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::SYSTEMErrEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SYSTEMErrEx>::insert_copy (
      _tao_any,
      SYSTEMErr::SYSTEMErrEx::_tao_any_destructor,
      SYSTEMErr::_tc_SYSTEMErrEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::SYSTEMErrEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SYSTEMErrEx>::insert (
      _tao_any,
      SYSTEMErr::SYSTEMErrEx::_tao_any_destructor,
      SYSTEMErr::_tc_SYSTEMErrEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::SYSTEMErrEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::SYSTEMErrEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::SYSTEMErrEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::SYSTEMErrEx>::extract (
        _tao_any,
        SYSTEMErr::SYSTEMErrEx::_tao_any_destructor,
        SYSTEMErr::_tc_SYSTEMErrEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::AlreadyInAutomaticEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::AlreadyInAutomaticEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::AlreadyInAutomaticEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_AlreadyInAutomaticEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::AlreadyInAutomaticEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::AlreadyInAutomaticEx>::insert (
        _tao_any,
        ::SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_AlreadyInAutomaticEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::AlreadyInAutomaticEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::AlreadyInAutomaticEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::AlreadyInAutomaticEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::AlreadyInAutomaticEx>::extract (
          _tao_any,
          ::SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_AlreadyInAutomaticEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::AlreadyInAutomaticEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::AlreadyInAutomaticEx>::insert_copy (
      _tao_any,
      SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor,
      SYSTEMErr::_tc_AlreadyInAutomaticEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::AlreadyInAutomaticEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::AlreadyInAutomaticEx>::insert (
      _tao_any,
      SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor,
      SYSTEMErr::_tc_AlreadyInAutomaticEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::AlreadyInAutomaticEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::AlreadyInAutomaticEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::AlreadyInAutomaticEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::AlreadyInAutomaticEx>::extract (
        _tao_any,
        SYSTEMErr::AlreadyInAutomaticEx::_tao_any_destructor,
        SYSTEMErr::_tc_AlreadyInAutomaticEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::PositionOutOfLimitsEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::PositionOutOfLimitsEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::PositionOutOfLimitsEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_PositionOutOfLimitsEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::PositionOutOfLimitsEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::PositionOutOfLimitsEx>::insert (
        _tao_any,
        ::SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_PositionOutOfLimitsEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::PositionOutOfLimitsEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::PositionOutOfLimitsEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::PositionOutOfLimitsEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::PositionOutOfLimitsEx>::extract (
          _tao_any,
          ::SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_PositionOutOfLimitsEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::PositionOutOfLimitsEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::PositionOutOfLimitsEx>::insert_copy (
      _tao_any,
      SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor,
      SYSTEMErr::_tc_PositionOutOfLimitsEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::PositionOutOfLimitsEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::PositionOutOfLimitsEx>::insert (
      _tao_any,
      SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor,
      SYSTEMErr::_tc_PositionOutOfLimitsEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::PositionOutOfLimitsEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::PositionOutOfLimitsEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::PositionOutOfLimitsEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::PositionOutOfLimitsEx>::extract (
        _tao_any,
        SYSTEMErr::PositionOutOfLimitsEx::_tao_any_destructor,
        SYSTEMErr::_tc_PositionOutOfLimitsEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::ProposalNotYetReadyEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::ProposalNotYetReadyEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::ProposalNotYetReadyEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_ProposalNotYetReadyEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::ProposalNotYetReadyEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::ProposalNotYetReadyEx>::insert (
        _tao_any,
        ::SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_ProposalNotYetReadyEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::ProposalNotYetReadyEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::ProposalNotYetReadyEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::ProposalNotYetReadyEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::ProposalNotYetReadyEx>::extract (
          _tao_any,
          ::SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_ProposalNotYetReadyEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::ProposalNotYetReadyEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ProposalNotYetReadyEx>::insert_copy (
      _tao_any,
      SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor,
      SYSTEMErr::_tc_ProposalNotYetReadyEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::ProposalNotYetReadyEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ProposalNotYetReadyEx>::insert (
      _tao_any,
      SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor,
      SYSTEMErr::_tc_ProposalNotYetReadyEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::ProposalNotYetReadyEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::ProposalNotYetReadyEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::ProposalNotYetReadyEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::ProposalNotYetReadyEx>::extract (
        _tao_any,
        SYSTEMErr::ProposalNotYetReadyEx::_tao_any_destructor,
        SYSTEMErr::_tc_ProposalNotYetReadyEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::InvalidProposalStatusTransitionEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::InvalidProposalStatusTransitionEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_InvalidProposalStatusTransitionEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::InvalidProposalStatusTransitionEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::InvalidProposalStatusTransitionEx>::insert (
        _tao_any,
        ::SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_InvalidProposalStatusTransitionEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::InvalidProposalStatusTransitionEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::InvalidProposalStatusTransitionEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::InvalidProposalStatusTransitionEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::InvalidProposalStatusTransitionEx>::extract (
          _tao_any,
          ::SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_InvalidProposalStatusTransitionEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::InvalidProposalStatusTransitionEx>::insert_copy (
      _tao_any,
      SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor,
      SYSTEMErr::_tc_InvalidProposalStatusTransitionEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::InvalidProposalStatusTransitionEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::InvalidProposalStatusTransitionEx>::insert (
      _tao_any,
      SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor,
      SYSTEMErr::_tc_InvalidProposalStatusTransitionEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::InvalidProposalStatusTransitionEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::InvalidProposalStatusTransitionEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::InvalidProposalStatusTransitionEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::InvalidProposalStatusTransitionEx>::extract (
        _tao_any,
        SYSTEMErr::InvalidProposalStatusTransitionEx::_tao_any_destructor,
        SYSTEMErr::_tc_InvalidProposalStatusTransitionEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::ImageAlreadyStoredEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::ImageAlreadyStoredEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::ImageAlreadyStoredEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_ImageAlreadyStoredEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::ImageAlreadyStoredEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::ImageAlreadyStoredEx>::insert (
        _tao_any,
        ::SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_ImageAlreadyStoredEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::ImageAlreadyStoredEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::ImageAlreadyStoredEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::ImageAlreadyStoredEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::ImageAlreadyStoredEx>::extract (
          _tao_any,
          ::SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_ImageAlreadyStoredEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::ImageAlreadyStoredEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ImageAlreadyStoredEx>::insert_copy (
      _tao_any,
      SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor,
      SYSTEMErr::_tc_ImageAlreadyStoredEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::ImageAlreadyStoredEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::ImageAlreadyStoredEx>::insert (
      _tao_any,
      SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor,
      SYSTEMErr::_tc_ImageAlreadyStoredEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::ImageAlreadyStoredEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::ImageAlreadyStoredEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::ImageAlreadyStoredEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::ImageAlreadyStoredEx>::extract (
        _tao_any,
        SYSTEMErr::ImageAlreadyStoredEx::_tao_any_destructor,
        SYSTEMErr::_tc_ImageAlreadyStoredEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::CameraIsOffEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::CameraIsOffEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::CameraIsOffEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::CameraIsOffEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_CameraIsOffEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::CameraIsOffEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::CameraIsOffEx>::insert (
        _tao_any,
        ::SYSTEMErr::CameraIsOffEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_CameraIsOffEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::CameraIsOffEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::CameraIsOffEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::CameraIsOffEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::CameraIsOffEx>::extract (
          _tao_any,
          ::SYSTEMErr::CameraIsOffEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_CameraIsOffEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::CameraIsOffEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::CameraIsOffEx>::insert_copy (
      _tao_any,
      SYSTEMErr::CameraIsOffEx::_tao_any_destructor,
      SYSTEMErr::_tc_CameraIsOffEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::CameraIsOffEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::CameraIsOffEx>::insert (
      _tao_any,
      SYSTEMErr::CameraIsOffEx::_tao_any_destructor,
      SYSTEMErr::_tc_CameraIsOffEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::CameraIsOffEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::CameraIsOffEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::CameraIsOffEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::CameraIsOffEx>::extract (
        _tao_any,
        SYSTEMErr::CameraIsOffEx::_tao_any_destructor,
        SYSTEMErr::_tc_CameraIsOffEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyRunningEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::SchedulerAlreadyRunningEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::SchedulerAlreadyRunningEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_SchedulerAlreadyRunningEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::SchedulerAlreadyRunningEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::SchedulerAlreadyRunningEx>::insert (
        _tao_any,
        ::SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_SchedulerAlreadyRunningEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::SchedulerAlreadyRunningEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::SchedulerAlreadyRunningEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::SchedulerAlreadyRunningEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::SchedulerAlreadyRunningEx>::extract (
          _tao_any,
          ::SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_SchedulerAlreadyRunningEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::SchedulerAlreadyRunningEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyRunningEx>::insert_copy (
      _tao_any,
      SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor,
      SYSTEMErr::_tc_SchedulerAlreadyRunningEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::SchedulerAlreadyRunningEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyRunningEx>::insert (
      _tao_any,
      SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor,
      SYSTEMErr::_tc_SchedulerAlreadyRunningEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::SchedulerAlreadyRunningEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::SchedulerAlreadyRunningEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::SchedulerAlreadyRunningEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyRunningEx>::extract (
        _tao_any,
        SYSTEMErr::SchedulerAlreadyRunningEx::_tao_any_destructor,
        SYSTEMErr::_tc_SchedulerAlreadyRunningEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyStoppedEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::SchedulerAlreadyStoppedEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_SchedulerAlreadyStoppedEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::SchedulerAlreadyStoppedEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::SchedulerAlreadyStoppedEx>::insert (
        _tao_any,
        ::SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_SchedulerAlreadyStoppedEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::SchedulerAlreadyStoppedEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::SchedulerAlreadyStoppedEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::SchedulerAlreadyStoppedEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::SchedulerAlreadyStoppedEx>::extract (
          _tao_any,
          ::SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_SchedulerAlreadyStoppedEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyStoppedEx>::insert_copy (
      _tao_any,
      SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor,
      SYSTEMErr::_tc_SchedulerAlreadyStoppedEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::SchedulerAlreadyStoppedEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyStoppedEx>::insert (
      _tao_any,
      SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor,
      SYSTEMErr::_tc_SchedulerAlreadyStoppedEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::SchedulerAlreadyStoppedEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::SchedulerAlreadyStoppedEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::SchedulerAlreadyStoppedEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::SchedulerAlreadyStoppedEx>::extract (
        _tao_any,
        SYSTEMErr::SchedulerAlreadyStoppedEx::_tao_any_destructor,
        SYSTEMErr::_tc_SchedulerAlreadyStoppedEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::NoProposalExecutingEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::NoProposalExecutingEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::NoProposalExecutingEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_NoProposalExecutingEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::NoProposalExecutingEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::NoProposalExecutingEx>::insert (
        _tao_any,
        ::SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_NoProposalExecutingEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::NoProposalExecutingEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::NoProposalExecutingEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::NoProposalExecutingEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::NoProposalExecutingEx>::extract (
          _tao_any,
          ::SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_NoProposalExecutingEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::NoProposalExecutingEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::NoProposalExecutingEx>::insert_copy (
      _tao_any,
      SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor,
      SYSTEMErr::_tc_NoProposalExecutingEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::NoProposalExecutingEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::NoProposalExecutingEx>::insert (
      _tao_any,
      SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor,
      SYSTEMErr::_tc_NoProposalExecutingEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::NoProposalExecutingEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::NoProposalExecutingEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::NoProposalExecutingEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::NoProposalExecutingEx>::extract (
        _tao_any,
        SYSTEMErr::NoProposalExecutingEx::_tao_any_destructor,
        SYSTEMErr::_tc_NoProposalExecutingEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::SystemInAutoModeEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::SystemInAutoModeEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::SystemInAutoModeEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_SystemInAutoModeEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::SystemInAutoModeEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::SystemInAutoModeEx>::insert (
        _tao_any,
        ::SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_SystemInAutoModeEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::SystemInAutoModeEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::SystemInAutoModeEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::SystemInAutoModeEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::SystemInAutoModeEx>::extract (
          _tao_any,
          ::SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_SystemInAutoModeEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::SystemInAutoModeEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SystemInAutoModeEx>::insert_copy (
      _tao_any,
      SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor,
      SYSTEMErr::_tc_SystemInAutoModeEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::SystemInAutoModeEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::SystemInAutoModeEx>::insert (
      _tao_any,
      SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor,
      SYSTEMErr::_tc_SystemInAutoModeEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::SystemInAutoModeEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::SystemInAutoModeEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::SystemInAutoModeEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::SystemInAutoModeEx>::extract (
        _tao_any,
        SYSTEMErr::SystemInAutoModeEx::_tao_any_destructor,
        SYSTEMErr::_tc_SystemInAutoModeEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:41
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<SYSTEMErr::CannotOpenDeviceEx>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SYSTEMErr
{
  

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::CannotOpenDeviceEx &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::CannotOpenDeviceEx>::insert_copy (
        _tao_any,
        ::SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_CannotOpenDeviceEx,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::SYSTEMErr::CannotOpenDeviceEx *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::SYSTEMErr::CannotOpenDeviceEx>::insert (
        _tao_any,
        ::SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor,
        ::SYSTEMErr::_tc_CannotOpenDeviceEx,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::SYSTEMErr::CannotOpenDeviceEx *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::SYSTEMErr::CannotOpenDeviceEx *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::SYSTEMErr::CannotOpenDeviceEx *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::SYSTEMErr::CannotOpenDeviceEx>::extract (
          _tao_any,
          ::SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor,
          ::SYSTEMErr::_tc_CannotOpenDeviceEx,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SYSTEMErr::CannotOpenDeviceEx &_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::CannotOpenDeviceEx>::insert_copy (
      _tao_any,
      SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor,
      SYSTEMErr::_tc_CannotOpenDeviceEx,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SYSTEMErr::CannotOpenDeviceEx *_tao_elem)
{
  TAO::Any_Dual_Impl_T<SYSTEMErr::CannotOpenDeviceEx>::insert (
      _tao_any,
      SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor,
      SYSTEMErr::_tc_CannotOpenDeviceEx,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SYSTEMErr::CannotOpenDeviceEx *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const SYSTEMErr::CannotOpenDeviceEx *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SYSTEMErr::CannotOpenDeviceEx *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SYSTEMErr::CannotOpenDeviceEx>::extract (
        _tao_any,
        SYSTEMErr::CannotOpenDeviceEx::_tao_any_destructor,
        SYSTEMErr::_tc_CannotOpenDeviceEx,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::SYSTEMErrEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::SYSTEMErrEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::AlreadyInAutomaticEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::AlreadyInAutomaticEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::PositionOutOfLimitsEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::PositionOutOfLimitsEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::ProposalNotYetReadyEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::ProposalNotYetReadyEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::InvalidProposalStatusTransitionEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::ImageAlreadyStoredEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::ImageAlreadyStoredEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::CameraIsOffEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::CameraIsOffEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::SchedulerAlreadyRunningEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::SchedulerAlreadyRunningEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::SchedulerAlreadyStoppedEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::NoProposalExecutingEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::NoProposalExecutingEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::SystemInAutoModeEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::SystemInAutoModeEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SYSTEMErr::CannotOpenDeviceEx &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.errorTrace)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SYSTEMErr::CannotOpenDeviceEx &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.errorTrace)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



