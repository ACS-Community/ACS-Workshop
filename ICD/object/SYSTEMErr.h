#ifndef _SYSTEMErr_H_
#define _SYSTEMErr_H_

/*******************************************************************************
* ALMA - Atacama Large Millimiter Array
* (c) European Southern Observatory, 2003 
*
*This library is free software; you can redistribute it and/or
*modify it under the terms of the GNU Lesser General Public
*License as published by the Free Software Foundation; either
*version 2.1 of the License, or (at your option) any later version.
*
*This library is distributed in the hope that it will be useful,
*but WITHOUT ANY WARRANTY; without even the implied warranty of
*MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*Lesser General Public License for more details.
*
*You should have received a copy of the GNU Lesser General Public
*License along with this library; if not, write to the Free Software
*Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*
* "@(#) $Id: AES2H.xslt,v 1.27 2012/02/29 12:50:09 tstaig Exp $"
*************  THIS FILE IS AUTOMATICALLY GENERATED !!!!!!
*/
	
#include "SYSTEMErrC.h"

#include "acserrExceptionManager.h"
#include "acserrGenExport.h"

namespace SYSTEMErr
{

class acserrGen_EXPORT AlreadyInAutomaticCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = AlreadyInAutomatic;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return AlreadyInAutomaticCompletion::m_shortDescription; }
		
	AlreadyInAutomaticCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	AlreadyInAutomaticCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	AlreadyInAutomaticCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	AlreadyInAutomaticCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	AlreadyInAutomaticCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	AlreadyInAutomaticCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT PositionOutOfLimitsCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = PositionOutOfLimits;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return PositionOutOfLimitsCompletion::m_shortDescription; }
		
	PositionOutOfLimitsCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	PositionOutOfLimitsCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	PositionOutOfLimitsCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	PositionOutOfLimitsCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	PositionOutOfLimitsCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	PositionOutOfLimitsCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT ProposalNotYetReadyCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = ProposalNotYetReady;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return ProposalNotYetReadyCompletion::m_shortDescription; }
		
	ProposalNotYetReadyCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	ProposalNotYetReadyCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	ProposalNotYetReadyCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	ProposalNotYetReadyCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	ProposalNotYetReadyCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	ProposalNotYetReadyCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT InvalidProposalStatusTransitionCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = InvalidProposalStatusTransition;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return InvalidProposalStatusTransitionCompletion::m_shortDescription; }
		
	InvalidProposalStatusTransitionCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	InvalidProposalStatusTransitionCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	InvalidProposalStatusTransitionCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	InvalidProposalStatusTransitionCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	InvalidProposalStatusTransitionCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	InvalidProposalStatusTransitionCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT ImageAlreadyStoredCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = ImageAlreadyStored;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return ImageAlreadyStoredCompletion::m_shortDescription; }
		
	ImageAlreadyStoredCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	ImageAlreadyStoredCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	ImageAlreadyStoredCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	ImageAlreadyStoredCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	ImageAlreadyStoredCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	ImageAlreadyStoredCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT CameraIsOffCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = CameraIsOff;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return CameraIsOffCompletion::m_shortDescription; }
		
	CameraIsOffCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	CameraIsOffCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	CameraIsOffCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	CameraIsOffCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	CameraIsOffCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	CameraIsOffCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT SchedulerAlreadyRunningCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = SchedulerAlreadyRunning;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return SchedulerAlreadyRunningCompletion::m_shortDescription; }
		
	SchedulerAlreadyRunningCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	SchedulerAlreadyRunningCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	SchedulerAlreadyRunningCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	SchedulerAlreadyRunningCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	SchedulerAlreadyRunningCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	SchedulerAlreadyRunningCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT SchedulerAlreadyStoppedCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = SchedulerAlreadyStopped;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return SchedulerAlreadyStoppedCompletion::m_shortDescription; }
		
	SchedulerAlreadyStoppedCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	SchedulerAlreadyStoppedCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	SchedulerAlreadyStoppedCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	SchedulerAlreadyStoppedCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	SchedulerAlreadyStoppedCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	SchedulerAlreadyStoppedCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT NoProposalExecutingCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = NoProposalExecuting;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return NoProposalExecutingCompletion::m_shortDescription; }
		
	NoProposalExecutingCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	NoProposalExecutingCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	NoProposalExecutingCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	NoProposalExecutingCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	NoProposalExecutingCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	NoProposalExecutingCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT SystemInAutoModeCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = SystemInAutoMode;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return SystemInAutoModeCompletion::m_shortDescription; }
		
	SystemInAutoModeCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	SystemInAutoModeCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	SystemInAutoModeCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	SystemInAutoModeCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	SystemInAutoModeCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	SystemInAutoModeCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};

class acserrGen_EXPORT CannotOpenDeviceCompletion: public ACSErr::CompletionImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr; // = 900907
	static const ACSErr::ErrorCode m_code = CannotOpenDevice;
	static const char m_shortDescription[];
		
	public:
	
	static bool isEqual(ACSErr::Completion &completion);
	
	const char * getShortDescription() { return CannotOpenDeviceCompletion::m_shortDescription; }
		
	CannotOpenDeviceCompletion (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
					
	CannotOpenDeviceCompletion (ACSErr::Completion *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(*pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	CannotOpenDeviceCompletion (const ACSErr::Completion &pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	CannotOpenDeviceCompletion (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(pc, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
		
	CannotOpenDeviceCompletion (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}	
						
	template <class T >
	CannotOpenDeviceCompletion (const T &pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
		ACSErr::CompletionImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}

};


 // ******************************************************************* 
 //                                excptions for type:
 // ******************************************************************* 
class SYSTEMErrExImpl : public ACSErr::ACSbaseExImpl
{
	protected:
	SYSTEMErrExImpl(const ACSErr::ErrorTrace &et) : ACSErr::ACSbaseExImpl(et) {}
	
	SYSTEMErrExImpl (ACSErr::ACSErrType et, ACSErr::ErrorCode ec, const char* file, 
						int line, const char* routine, const char* sd,
					   	ACSErr::Severity severity):
		   			ACSErr::ACSbaseExImpl(et, ec, file, line, routine, sd, severity) {}
				
	SYSTEMErrExImpl (const ACSErr::ErrorTrace &pet,
						   ACSErr::ACSErrType et, ACSErr::ErrorCode ec,
						   const char* file, int line, const char* routine, const char* sd, 
						   ACSErr::Severity severity) :
					ACSErr::ACSbaseExImpl(pet, et, ec, file, line, routine, sd, severity) {}
	
	public:
					
	SYSTEMErrExImpl (SYSTEMErr::SYSTEMErrEx & ex) : ACSErr::ACSbaseExImpl(ex.errorTrace) {}
			
	SYSTEMErr::SYSTEMErrEx getSYSTEMErrEx () { return SYSTEMErr::SYSTEMErrEx (getErrorTrace()); }
};


 // ******************************************************************* 
 //                                excptions for codes:
 // ******************************************************************* 
class acserrGen_EXPORT AlreadyInAutomaticExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = AlreadyInAutomatic;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	AlreadyInAutomaticExImpl(const AlreadyInAutomaticExImpl& ex) :
			SYSTEMErrExImpl(const_cast<AlreadyInAutomaticExImpl&>(ex).getErrorTrace()) {}
		
	AlreadyInAutomaticExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	AlreadyInAutomaticExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	AlreadyInAutomaticExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	AlreadyInAutomaticExImpl (const SYSTEMErr::AlreadyInAutomaticEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::AlreadyInAutomaticEx getAlreadyInAutomaticEx () { return SYSTEMErr::AlreadyInAutomaticEx (getErrorTrace()); }
	
	template <class T >
	AlreadyInAutomaticExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT PositionOutOfLimitsExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = PositionOutOfLimits;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	PositionOutOfLimitsExImpl(const PositionOutOfLimitsExImpl& ex) :
			SYSTEMErrExImpl(const_cast<PositionOutOfLimitsExImpl&>(ex).getErrorTrace()) {}
		
	PositionOutOfLimitsExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	PositionOutOfLimitsExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	PositionOutOfLimitsExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	PositionOutOfLimitsExImpl (const SYSTEMErr::PositionOutOfLimitsEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::PositionOutOfLimitsEx getPositionOutOfLimitsEx () { return SYSTEMErr::PositionOutOfLimitsEx (getErrorTrace()); }
	
	template <class T >
	PositionOutOfLimitsExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT ProposalNotYetReadyExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = ProposalNotYetReady;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	ProposalNotYetReadyExImpl(const ProposalNotYetReadyExImpl& ex) :
			SYSTEMErrExImpl(const_cast<ProposalNotYetReadyExImpl&>(ex).getErrorTrace()) {}
		
	ProposalNotYetReadyExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	ProposalNotYetReadyExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	ProposalNotYetReadyExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	ProposalNotYetReadyExImpl (const SYSTEMErr::ProposalNotYetReadyEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::ProposalNotYetReadyEx getProposalNotYetReadyEx () { return SYSTEMErr::ProposalNotYetReadyEx (getErrorTrace()); }
	
	template <class T >
	ProposalNotYetReadyExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT InvalidProposalStatusTransitionExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = InvalidProposalStatusTransition;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	InvalidProposalStatusTransitionExImpl(const InvalidProposalStatusTransitionExImpl& ex) :
			SYSTEMErrExImpl(const_cast<InvalidProposalStatusTransitionExImpl&>(ex).getErrorTrace()) {}
		
	InvalidProposalStatusTransitionExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	InvalidProposalStatusTransitionExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	InvalidProposalStatusTransitionExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	InvalidProposalStatusTransitionExImpl (const SYSTEMErr::InvalidProposalStatusTransitionEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::InvalidProposalStatusTransitionEx getInvalidProposalStatusTransitionEx () { return SYSTEMErr::InvalidProposalStatusTransitionEx (getErrorTrace()); }
	
	template <class T >
	InvalidProposalStatusTransitionExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT ImageAlreadyStoredExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = ImageAlreadyStored;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	ImageAlreadyStoredExImpl(const ImageAlreadyStoredExImpl& ex) :
			SYSTEMErrExImpl(const_cast<ImageAlreadyStoredExImpl&>(ex).getErrorTrace()) {}
		
	ImageAlreadyStoredExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	ImageAlreadyStoredExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	ImageAlreadyStoredExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	ImageAlreadyStoredExImpl (const SYSTEMErr::ImageAlreadyStoredEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::ImageAlreadyStoredEx getImageAlreadyStoredEx () { return SYSTEMErr::ImageAlreadyStoredEx (getErrorTrace()); }
	
	template <class T >
	ImageAlreadyStoredExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT CameraIsOffExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = CameraIsOff;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	CameraIsOffExImpl(const CameraIsOffExImpl& ex) :
			SYSTEMErrExImpl(const_cast<CameraIsOffExImpl&>(ex).getErrorTrace()) {}
		
	CameraIsOffExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	CameraIsOffExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	CameraIsOffExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	CameraIsOffExImpl (const SYSTEMErr::CameraIsOffEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::CameraIsOffEx getCameraIsOffEx () { return SYSTEMErr::CameraIsOffEx (getErrorTrace()); }
	
	template <class T >
	CameraIsOffExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT SchedulerAlreadyRunningExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = SchedulerAlreadyRunning;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	SchedulerAlreadyRunningExImpl(const SchedulerAlreadyRunningExImpl& ex) :
			SYSTEMErrExImpl(const_cast<SchedulerAlreadyRunningExImpl&>(ex).getErrorTrace()) {}
		
	SchedulerAlreadyRunningExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	SchedulerAlreadyRunningExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	SchedulerAlreadyRunningExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	SchedulerAlreadyRunningExImpl (const SYSTEMErr::SchedulerAlreadyRunningEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::SchedulerAlreadyRunningEx getSchedulerAlreadyRunningEx () { return SYSTEMErr::SchedulerAlreadyRunningEx (getErrorTrace()); }
	
	template <class T >
	SchedulerAlreadyRunningExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT SchedulerAlreadyStoppedExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = SchedulerAlreadyStopped;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	SchedulerAlreadyStoppedExImpl(const SchedulerAlreadyStoppedExImpl& ex) :
			SYSTEMErrExImpl(const_cast<SchedulerAlreadyStoppedExImpl&>(ex).getErrorTrace()) {}
		
	SchedulerAlreadyStoppedExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	SchedulerAlreadyStoppedExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	SchedulerAlreadyStoppedExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	SchedulerAlreadyStoppedExImpl (const SYSTEMErr::SchedulerAlreadyStoppedEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::SchedulerAlreadyStoppedEx getSchedulerAlreadyStoppedEx () { return SYSTEMErr::SchedulerAlreadyStoppedEx (getErrorTrace()); }
	
	template <class T >
	SchedulerAlreadyStoppedExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT NoProposalExecutingExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = NoProposalExecuting;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	NoProposalExecutingExImpl(const NoProposalExecutingExImpl& ex) :
			SYSTEMErrExImpl(const_cast<NoProposalExecutingExImpl&>(ex).getErrorTrace()) {}
		
	NoProposalExecutingExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	NoProposalExecutingExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	NoProposalExecutingExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	NoProposalExecutingExImpl (const SYSTEMErr::NoProposalExecutingEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::NoProposalExecutingEx getNoProposalExecutingEx () { return SYSTEMErr::NoProposalExecutingEx (getErrorTrace()); }
	
	template <class T >
	NoProposalExecutingExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT SystemInAutoModeExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = SystemInAutoMode;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	SystemInAutoModeExImpl(const SystemInAutoModeExImpl& ex) :
			SYSTEMErrExImpl(const_cast<SystemInAutoModeExImpl&>(ex).getErrorTrace()) {}
		
	SystemInAutoModeExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	SystemInAutoModeExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	SystemInAutoModeExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	SystemInAutoModeExImpl (const SYSTEMErr::SystemInAutoModeEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::SystemInAutoModeEx getSystemInAutoModeEx () { return SYSTEMErr::SystemInAutoModeEx (getErrorTrace()); }
	
	template <class T >
	SystemInAutoModeExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

class acserrGen_EXPORT CannotOpenDeviceExImpl: public SYSTEMErrExImpl
{
	static const ACSErr::ACSErrType m_etype=ACSErr::SYSTEMErr;
	static const ACSErr::ErrorCode m_code = CannotOpenDevice;
	static const char m_shortDescription[]  ;
	
	public:
		static bool isEqual(ACSErr::ACSbaseExImpl &ex);

        static const char * getShortDescription() { return m_shortDescription;}
	CannotOpenDeviceExImpl(const CannotOpenDeviceExImpl& ex) :
			SYSTEMErrExImpl(const_cast<CannotOpenDeviceExImpl&>(ex).getErrorTrace()) {}
		
	CannotOpenDeviceExImpl (const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
	
	CannotOpenDeviceExImpl (const ACSErr::ErrorTrace &et, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(et, m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	CannotOpenDeviceExImpl (ACSErr::CompletionImpl *pc, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl((pc->isErrorFree() ? ACSErr::ErrorTrace()  : pc->getErrorTraceHelper()->getErrorTrace()), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}
				
	CannotOpenDeviceExImpl (const SYSTEMErr::CannotOpenDeviceEx & ex) : 
			SYSTEMErrExImpl(ex.errorTrace) {}
			
	SYSTEMErr::CannotOpenDeviceEx getCannotOpenDeviceEx () { return SYSTEMErr::CannotOpenDeviceEx (getErrorTrace()); }
	
	template <class T >
	CannotOpenDeviceExImpl (const T& pe, const char* file, int line, const char* routine, ACSErr::Severity severity=DEFAULT_SEVERITY) : 
			SYSTEMErrExImpl(ETHolder<T>(pe).getErrorTrace(), m_etype, m_code, file, line, routine, m_shortDescription, severity) {}


};

}

#endif
